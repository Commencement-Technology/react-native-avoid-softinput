"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6675],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),f=r,m=u["".concat(c,".").concat(f)]||u[f]||d[f]||i;return n?o.createElement(m,a(a({ref:t},p),{},{components:n})):o.createElement(m,a({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=f;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7769:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const i={id:"recipes-sticky-footer",title:"Sticky footer recipe",sidebar_label:"Sticky footer",keywords:["react-native-avoid-softinput","sticky footer","recipe"]},a=void 0,s={unversionedId:"recipes/recipes-sticky-footer",id:"version-4.0.x/recipes/recipes-sticky-footer",title:"Sticky footer recipe",description:"To handle complex layouts, where you want to make visible parts of UI inside and outside of scroll component (like scrollable text fields and fixed CTA button), you should manually handle parts that are not in the current focused input's container.",source:"@site/versioned_docs/version-4.0.x/recipes/STICKY_FOOTER.mdx",sourceDirName:"recipes",slug:"/recipes/recipes-sticky-footer",permalink:"/react-native-avoid-softinput/docs/recipes/recipes-sticky-footer",draft:!1,editUrl:"https://github.com/mateusz1913/react-native-avoid-softinput/tree/main/docs/versioned_docs/version-4.0.x/recipes/STICKY_FOOTER.mdx",tags:[],version:"4.0.x",frontMatter:{id:"recipes-sticky-footer",title:"Sticky footer recipe",sidebar_label:"Sticky footer",keywords:["react-native-avoid-softinput","sticky footer","recipe"]},sidebar:"docsSidebar",previous:{title:"Bottom sheet",permalink:"/react-native-avoid-softinput/docs/recipes/recipes-bottom-sheet"},next:{title:"Animations",permalink:"/react-native-avoid-softinput/docs/recipes/recipes-animations"}},c={},l=[],p={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To handle complex layouts, where you want to make visible parts of UI inside and outside of scroll component (like scrollable text fields and fixed CTA button), you should manually handle parts that are not in the current focused input's container."),(0,r.kt)("p",null,'One use case is handling "sticky" CTA button fixed at the bottom of the screen with text fields displayed inside ',(0,r.kt)("inlineCode",{parentName:"p"},"ScrollView"),"."),(0,r.kt)("p",null,"To handle button manually, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"useSoftInputHeightChanged")," or combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"useSoftInputShown")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"useSoftInputHidden")," hooks to apply additional padding for button's container."),(0,r.kt)("p",null,"Check ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mateusz1913/react-native-avoid-softinput/blob/main/packages/app/src/screens/StickyFooterExample.tsx"},"StickyFooterExample"),' for a showcase of "sticky" footer behavior'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="packages/app/src/screens/StickyFooterExample.tsx"',title:'"packages/app/src/screens/StickyFooterExample.tsx"'},"import { useFocusEffect } from '@react-navigation/native';\nimport * as React from 'react';\nimport { ScrollView, StyleSheet, View } from 'react-native';\nimport { AvoidSoftInput, useSoftInputHeightChanged } from 'react-native-avoid-softinput';\nimport Animated, { useAnimatedStyle, useSharedValue, withTiming } from 'react-native-reanimated';\nimport { SafeAreaView } from 'react-native-safe-area-context';\n\nimport Button from '../components/Button';\nimport SingleInput from '../components/SingleInput';\nimport { styles as commonStyles } from '../consts/styles';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst NOOP = () => {};\n\nexport const StickyFooterExample: React.FC = () => {\n  const buttonContainerPaddingValue = useSharedValue(0);\n\n  const buttonContainerAnimatedStyle = useAnimatedStyle(() => {\n    return {\n      paddingBottom: buttonContainerPaddingValue.value,\n    };\n  });\n\n  const onFocusEffect = React.useCallback(() => {\n    AvoidSoftInput.setShouldMimicIOSBehavior(true);\n\n    return () => {\n      AvoidSoftInput.setShouldMimicIOSBehavior(false);\n    };\n  }, []);\n\n  useFocusEffect(onFocusEffect);\n\n  /**\n   * You can also use `useSoftInputShown` & `useSoftInputHidden`\n   *\n   * useSoftInputShown(({ softInputHeight }) => {\n   *   buttonContainerPaddingValue.value = withTiming(softInputHeight);\n   * });\n   *\n   * useSoftInputHidden(() => {\n   *   buttonContainerPaddingValue.value = withTiming(0);\n   * });\n   */\n  useSoftInputHeightChanged(({ softInputHeight }) => {\n    buttonContainerPaddingValue.value = withTiming(softInputHeight);\n  });\n\n  return <SafeAreaView edges={[ 'left', 'right', 'bottom' ]} style={commonStyles.screenContainer}>\n    <View style={styles.scrollWrapper}>\n      <ScrollView\n        contentContainerStyle={styles.scrollContainer}\n        contentInsetAdjustmentBehavior=\"always\"\n      >\n        <SingleInput />\n      </ScrollView>\n    </View>\n    <Animated.View style={[ buttonContainerAnimatedStyle, styles.ctaButtonWrapper ]}>\n      <View style={styles.ctaButtonContainer}>\n        <Button onPress={NOOP} title=\"Submit\" />\n      </View>\n    </Animated.View>\n  </SafeAreaView>;\n};\n\nconst styles = StyleSheet.create({\n  ctaButtonContainer: {\n    alignItems: 'center',\n    alignSelf: 'stretch',\n    borderRadius: 10,\n    borderWidth: 1,\n  },\n  ctaButtonWrapper: {\n    alignSelf: 'stretch',\n  },\n  scrollContainer: {\n    alignItems: 'center',\n    alignSelf: 'stretch',\n    borderRadius: 10,\n    borderWidth: 1,\n    flexGrow: 1,\n    justifyContent: 'center',\n    margin: 5,\n    padding: 10,\n  },\n  scrollWrapper: {\n    alignSelf: 'stretch',\n    flex: 1,\n  },\n});\n")))}u.isMDXComponent=!0}}]);