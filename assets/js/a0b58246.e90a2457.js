"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2346],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return v}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),l=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=l(r),v=a,f=p["".concat(s,".").concat(v)]||p[v]||u[v]||o;return r?n.createElement(f,i(i({ref:t},d),{},{components:r})):n.createElement(f,i({ref:t},d))}));function v(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},3634:function(e,t,r){r.r(t),r.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return l}});var n=r(3117),a=(r(7294),r(3905));const o={id:"alternatives",title:"Alternatives",sidebar_label:"Alternatives"},i=void 0,c={unversionedId:"guides/alternatives",id:"version-3.0.x/guides/alternatives",title:"Alternatives",description:"If, for whatever reason, the library does not satisfy your project's use case, you can check following alternatives (all of them are great and much better than KeyboardAvoidingView):",source:"@site/versioned_docs/version-3.0.x/guides/ALTERNATIVES.mdx",sourceDirName:"guides",slug:"/guides/alternatives",permalink:"/react-native-avoid-softinput/docs/guides/alternatives",draft:!1,editUrl:"https://github.com/mateusz1913/react-native-avoid-softinput/tree/main/docs/versioned_docs/version-3.0.x/guides/ALTERNATIVES.mdx",tags:[],version:"3.0.x",frontMatter:{id:"alternatives",title:"Alternatives",sidebar_label:"Alternatives"},sidebar:"docsSidebar",previous:{title:"Jest mock usage",permalink:"/react-native-avoid-softinput/docs/guides/jest-mock-usage"},next:{title:"Form",permalink:"/react-native-avoid-softinput/docs/recipes/recipes-form"}},s={},l=[{value:"react-native-keyboard-manager + <code>android:windowSoftInputMode=&quot;adjustResize&quot;</code>",id:"react-native-keyboard-manager--androidwindowsoftinputmodeadjustresize",level:2},{value:"react-native-keyboard-controller",id:"react-native-keyboard-controller",level:2},{value:"react-native-keyboard-aware-scroll-view",id:"react-native-keyboard-aware-scroll-view",level:2}],d={toc:l};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If, for whatever reason, the library does not satisfy your project's use case, you can check following alternatives (all of them are great and much better than KeyboardAvoidingView):"),(0,a.kt)("h2",{id:"react-native-keyboard-manager--androidwindowsoftinputmodeadjustresize"},(0,a.kt)("a",{parentName:"h2",href:"https://github.com/douglasjunior/react-native-keyboard-manager"},"react-native-keyboard-manager")," + ",(0,a.kt)("inlineCode",{parentName:"h2"},'android:windowSoftInputMode="adjustResize"')),(0,a.kt)("p",null,"On iOS, you can use react-native-keyboard-manager which under the hood uses well-known ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hackiftekhar/IQKeyboardManager"},"IQKeyboardManager"),". And for the Android, you might try default ",(0,a.kt)("inlineCode",{parentName:"p"},"adjustResize")," behavior."),(0,a.kt)("h2",{id:"react-native-keyboard-controller"},(0,a.kt)("a",{parentName:"h2",href:"https://github.com/kirillzyusko/react-native-keyboard-controller"},"react-native-keyboard-controller")),(0,a.kt)("p",null,"react-native-keyboard-controller has an interesting approach of detecting keyboard appearance on native side and letting you apply detected height to Reanimated or vanilla Animated views. It's written in Kotlin and Swift, it uses WindowInsetsCompat API on Android and it also supports Fabric & TurboModules from version 1.2.0."),(0,a.kt)("h2",{id:"react-native-keyboard-aware-scroll-view"},(0,a.kt)("a",{parentName:"h2",href:"https://github.com/APSL/react-native-keyboard-aware-scroll-view"},"react-native-keyboard-aware-scroll-view")),(0,a.kt)("p",null,"react-native-keyboard-aware-scroll-view can be used as a drop-in replacement for scroll containers that need to be keyboard aware. It has fully JS implementation, so it can be used in Expo Go apps."))}u.isMDXComponent=!0}}]);