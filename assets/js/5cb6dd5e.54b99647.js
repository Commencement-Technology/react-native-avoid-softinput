"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8734],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),f=i,m=d["".concat(l,".").concat(f)]||d[f]||p[f]||r;return n?o.createElement(m,a(a({ref:t},u),{},{components:n})):o.createElement(m,a({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},5014:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(7462),i=(n(7294),n(3905));const r={id:"recipes-sticky-footer",title:"Sticky footer recipe",sidebar_label:"Sticky footer"},a=void 0,s={unversionedId:"recipes/recipes-sticky-footer",id:"recipes/recipes-sticky-footer",title:"Sticky footer recipe",description:"To handle complex layouts, where you want to make visible parts of UI inside and outside of scroll component (like scrollable text fields and fixed CTA button), you should manually handle parts that are not in the current focused input's container.",source:"@site/docs/recipes/STICKY_FOOTER.mdx",sourceDirName:"recipes",slug:"/recipes/recipes-sticky-footer",permalink:"/react-native-avoid-softinput/docs/next/recipes/recipes-sticky-footer",draft:!1,editUrl:"https://github.com/mateusz1913/react-native-avoid-softinput/tree/main/docs/docs/recipes/STICKY_FOOTER.mdx",tags:[],version:"current",frontMatter:{id:"recipes-sticky-footer",title:"Sticky footer recipe",sidebar_label:"Sticky footer"},sidebar:"docsSidebar",previous:{title:"Bottom sheet",permalink:"/react-native-avoid-softinput/docs/next/recipes/recipes-bottom-sheet"},next:{title:"Animations",permalink:"/react-native-avoid-softinput/docs/next/recipes/recipes-animations"}},l={},c=[{value:"Example",id:"example",level:3}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To handle complex layouts, where you want to make visible parts of UI inside and outside of scroll component (like scrollable text fields and fixed CTA button), you should manually handle parts that are not in the current focused input's container."),(0,i.kt)("p",null,'One use case is handling "sticky" CTA button fixed at the bottom of the screen with text fields displayed inside ',(0,i.kt)("inlineCode",{parentName:"p"},"ScrollView"),"."),(0,i.kt)("p",null,"To handle button manually, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"useSoftInputHeightChanged")," or combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"useSoftInputShown")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"useSoftInputHidden")," hooks to apply additional padding for button's container."),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"export const StickyFooterExample: React.FC = () => {\n  /**\n   * You can store additional padding using Reanimated's shared value\n   *\n   * If you want to keep it simple, you can instead store it in React's useState\n   */\n  const buttonContainerPaddingValue = useSharedValue(0);\n\n  const buttonContainerAnimatedStyle = useAnimatedStyle(() => {\n    return {\n      paddingBottom: buttonContainerPaddingValue.value,\n    };\n  });\n\n  const onFocusEffect = useCallback(() => {\n    AvoidSoftInput.setShouldMimicIOSBehavior(true); // <---- Tell Android that library will handle keyboard insets manually to match iOS behavior\n\n    return () => {\n      AvoidSoftInput.setShouldMimicIOSBehavior(false);\n    };\n  }, []);\n\n  useFocusEffect(onFocusEffect);\n\n  useSoftInputHeightChanged(({ softInputHeight }) => {\n    /**\n     * Set/remove additional padding when soft input is visible/hidden\n     *\n     * You can save it in Reanimated's shared value and make smooth transition\n     * or just store it inside React's useState and add padding conditionally in render part\n     *\n     * You can also use `useSoftInputShown` & `useSoftInputHidden`\n     *\n     * useSoftInputShown(({ softInputHeight }) => {\n     *   buttonContainerPaddingValue.value = withTiming(softInputHeight);\n     * });\n     *\n     * useSoftInputHidden(() => {\n     *   buttonContainerPaddingValue.value = withTiming(0);\n     * });\n     */\n    buttonContainerPaddingValue.value = withTiming(softInputHeight);\n  });\n\n  return (\n    <SafeAreaView>\n      <View>\n        <ScrollView>\n          // ... form\n          <SingleInput />\n          // ... form\n        </ScrollView>\n      </View>\n      <Animated.View /** here add your additional padding */>\n        <View>\n          <Button />\n        </View>\n      </Animated.View>\n    </SafeAreaView>\n  );\n};\n")))}d.isMDXComponent=!0}}]);